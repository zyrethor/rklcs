這兩個版本的深度優先搜索（DFS）函數的差異在於 **`comp.pb(v)`（或添加到 `comp` 的操作）的位置**，這影響了搜索順序和結果。

### 第一種版本

```cpp
void dfs(int v) {
  used[v] = true;
  comp.pb(v);

  for (auto to : g[v]) {
    if (!used[to]) {
      dfs(to);
    }
  }
}
```

**特徵**：

1. `comp.pb(v)` 在進入節點 `v` 時立即執行。
2. 這意味著節點 `v` 是在它的鄰居尚未探索之前被加入到 `comp` 中。
3. 結果中，節點將按 **前序遍歷（pre-order traversal）** 的順序存儲，這是 DFS 遍歷節點的順序。

適用場合：如果你需要在遍歷過程中即時記錄節點，這種方式更為合適。

------

### 第二種版本

```cpp
void dfs(int v) {
  used[v] = true;

  for (auto to : g[v]) {
    if (!used[to]) {
      dfs(to);
    }
  }
  comp.pb(v);
}
```

**特徵**：

1. `comp.pb(v)` 在節點 `v` 的所有鄰居都探索完成後才執行。
2. 這意味著節點 `v` 是在回溯階段被加入到 `comp` 中。
3. 結果中，節點將按 **後序遍歷（post-order traversal）** 的順序存儲。

適用場合：如果你需要對節點進行拓撲排序或處理 DAG（有向無環圖）中的依賴關係，這種方式更為合適。

------

### 主要差異對比

| **版本**             | **`comp.pb(v)` 的執行時機** | **存儲順序** | **適用情況**                 |
| -------------------- | --------------------------- | ------------ | ---------------------------- |
| 第一種（pre-order）  | 進入節點 `v` 時             | 前序遍歷順序 | 即時記錄節點                 |
| 第二種（post-order） | 離開節點 `v` 時             | 後序遍歷順序 | 拓撲排序、依賴關係處理等場合 |

如果你需要對存儲的結果有特定需求（例如拓撲排序需要後序），應根據需求選擇相應的版本。