{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Notes","text":"<p>Just some notes.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"Algo/Mathematics/fft.html","title":"FFT","text":""},{"location":"Algo/Mathematics/fft.html#complex-number-struct","title":"Complex Number Struct","text":"<pre><code>struct comp {\n  double x, y;\n  comp(double x = .0, double y = .0) : x(x), y(y) {}\n  inline comp conj() { return comp(x, -y); }\n};\n\ninline comp operator +(const comp&amp; a, const comp&amp; b) {\n  return comp(a.x + b.x, a.y + b.y);\n}\n\ninline comp operator -(const comp&amp; a, const comp&amp; b) {\n  return comp(a.x - b.x, a.y - b.y);\n}\n\ninline comp operator *(const comp&amp; a, const comp&amp; b) {\n  return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\ninline comp operator /(const comp&amp; a, const double&amp; b) {\n  return comp(a.x / b, a.y / b);\n}\n</code></pre> <p>It defines a complex number struct, and its <code>+, -, *, /</code> calculation.</p>"},{"location":"Algo/Mathematics/fft.html#namespace-fft","title":"Namespace FFT","text":""},{"location":"Algo/Mathematics/fft.html#precalc","title":"precalc","text":"<pre><code>const double PI = acosl(-1.0);\nvector&lt;comp&gt; w[LOGN];\nvector&lt;int&gt; rv;\n\nvoid precalc() {\n  forn(st, LOGN) {\n    w[st].resize(1 &lt;&lt; st);\n    forn(i, 1 &lt;&lt; st) {\n      double ang = PI / (1 &lt;&lt; st) * i;\n      w[st][i] = comp(cos(ang), sin(ang));\n    }\n  }\n\n  rv.assign(1 &lt;&lt; LOGN, 0);\n  fore(i, 1, sz(rv)) {\n    rv[i] = (rv[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (LOGN - 1));\n  }\n}\n</code></pre> <p>w means omega, means rotation factors.</p> $$ e^{\\frac{2\\pi i}{n}} $$ <p>Here only pi because we divide to 2. st means n. w[st][i] is the value in complex number. rv is reverse bits, size = 2^LOGN. if 5 in 4 bits(0101), rv will be 10(1010).</p>"},{"location":"Algo/Mathematics/fft.html#multiply","title":"multiply","text":"<pre><code>int ln = 1;\nwhile (ln &lt; (sza + szb)) {\n  ln &lt;&lt;= 1;\n}\n\nforn(i, ln) {\n  aa[i] = (i &lt; sza ? a[i] : comp());\n}\nforn(i, ln) {\n  bb[i] = (i &lt; szb ? b[i] : comp());\n}\n</code></pre> <p>if a, b polynomial is power 2 and 3 sza + szb = 5 we get minimal 2^3 = 8 &gt; 5 ln = 8</p> <p></p> <p>then we copy a to aa, other in 0</p> <p> <pre><code>fft(aa, ln, false);\nfft(bb, ln, false);\n\nforn(i, ln) {\n  cc[i] = aa[i] * bb[i];\n}\n\nfft(cc, ln, true);\n\nszc = ln;\nforn(i, szc) {\n  c[i] = int(cc[i].x + 0.5);\n}\n</code></pre> do fft on aa and bb multiply aa and bb do reverse fft on cc normalize cc becuase it's double, use rounding to get int</p>"},{"location":"Algo/Mathematics/fft.html#fft_1","title":"fft","text":"<pre><code>int ln = __builtin_ctz(n);\nforn(i, n) {\n  int ni = rv[i] &gt;&gt; (LOGN - ln);\n  if (i &lt; ni)\n    swap(a[i], a[ni]);\n}\n</code></pre> <p><pre><code>int ni = rv[i] &gt;&gt; (LOGN - ln);\n</code></pre>  get ln = log2(n) get a[idx],  idx = reverse bit </p> <pre><code>for(int st = 0; st &lt; ln; st++) {\n  int len = 1 &lt;&lt; st;\n  for(int k = 0; k &lt; n; k+=(len &lt;&lt; 1)) {\n    fore(pos, k, k+len) {\n      comp l = a[pos];\n      comp r = a[pos+len] * w[st][pos-k];\n\n      a[pos] = l + r;\n      a[pos+len] = l - r;\n    }\n  }\n}\n</code></pre> <p> <pre><code>for(int st = 0; st &lt; ln; st++)\n</code></pre>  st = each steps, in this img = 3</p> <p><pre><code>int len = 1 &lt;&lt; st;\n</code></pre>  len = stride = $2^{st}$, in this img, 1, 2, 4</p> <p><pre><code>for(int k = 0; k &lt; n; k+=(len &lt;&lt; 1))\n</code></pre>  k = how many steps in each st, in this img, 4, 2, 1</p> <p><pre><code>fore(pos, k, k+len) {\n  comp l = a[pos];\n  comp r = a[pos+len] * w[st][pos-k];\n\n  a[pos] = l + r;\n  a[pos+len] = l - r;\n}\n</code></pre>  calculation</p> <p><pre><code>if (inv) {\n  forn(i, n) {\n    a[i] = a[i] / n;\n  }\n  reverse(a+1, a+n);\n}\n</code></pre> reverse fft</p>"},{"location":"Algo/Mathematics/fft.html#full-code","title":"Full Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)\n#define forn(i, n) for(int i = 0; i &lt; int(n); i++)\n#define sz(a) int((a).size())\n\nconst int LOGN = 19;\nconst int N = (1 &lt;&lt; LOGN) + 555;\n\nstruct comp {\n  double x, y;\n  comp(double x = .0, double y = .0) : x(x), y(y) {}\n  inline comp conj() { return comp(x, -y); }\n};\n\ninline comp operator +(const comp&amp; a, const comp&amp; b) {\n  return comp(a.x + b.x, a.y + b.y);\n}\n\ninline comp operator -(const comp&amp; a, const comp&amp; b) {\n  return comp(a.x - b.x, a.y - b.y);\n}\n\ninline comp operator *(const comp&amp; a, const comp&amp; b) {\n  return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\ninline comp operator /(const comp&amp; a, const double&amp; b) {\n  return comp(a.x / b, a.y / b);\n}\n\nnamespace FFT {\nconst double PI = acosl(-1.0);\nvector&lt;comp&gt; w[LOGN];\nvector&lt;int&gt; rv;\n\nvoid precalc() {\n  forn(st, LOGN) {\n    w[st].resize(1 &lt;&lt; st);\n    forn(i, 1 &lt;&lt; st) {\n      double ang = PI / (1 &lt;&lt; st) * i;\n      w[st][i] = comp(cos(ang), sin(ang));\n    }\n  }\n\n  rv.assign(1 &lt;&lt; LOGN, 0);\n  fore(i, 1, sz(rv)) {\n    rv[i] = (rv[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (LOGN - 1));\n  }\n}\n\ninline void fft(comp a[N], int n, bool inv) {\n  int ln = __builtin_ctz(n);\n  forn(i, n) {\n    int ni = rv[i] &gt;&gt; (LOGN - ln);\n    if (i &lt; ni)\n      swap(a[i], a[ni]);\n  }\n\n  for(int st = 0; st &lt; ln; st++) {\n    int len = 1 &lt;&lt; st;\n    for(int k = 0; k &lt; n; k+=(len &lt;&lt; 1)) {\n      fore(pos, k, k+len) {\n        comp l = a[pos];\n        comp r = a[pos+len] * w[st][pos-k];\n\n        a[pos] = l + r;\n        a[pos+len] = l - r;\n      }\n    }\n  }\n\n  if (inv) {\n    forn(i, n) {\n      a[i] = a[i] / n;\n    }\n    reverse(a+1, a+n);\n  }\n\n}\n\ncomp aa[N], bb[N], cc[N];\ninline void multiply(int a[N], int sza, int b[N], int szb, int c[N], int&amp; szc) {\n  int ln = 1;\n  while (ln &lt; (sza + szb)) {\n    ln &lt;&lt;= 1;\n  }\n\n  forn(i, ln) {\n    aa[i] = (i &lt; sza ? a[i] : comp());\n  }\n  forn(i, ln) {\n    bb[i] = (i &lt; szb ? b[i] : comp());\n  }\n\n  fft(aa, ln, false);\n  fft(bb, ln, false);\n\n  forn(i, ln) {\n    cc[i] = aa[i] * bb[i];\n  }\n\n  fft(cc, ln, true);\n\n  szc = ln;\n  forn(i, szc) {\n    c[i] = int(cc[i].x + 0.5);\n  }\n}\n\n}\n\nint main() {\n  int a[N] = {1, 2, 3};\n  int b[N] = {4, 5, 6};\n  int c[N];\n\n  FFT::precalc();\n\n  int szc;\n  FFT::multiply(a, 3, b, 3, c, szc);\n\n  forn(i, szc) {\n    cout &lt;&lt; c[i] &lt;&lt; \" \";\n  }\n  cout &lt;&lt; \"\\n\";\n\n  return 0;\n}\n</code></pre>"},{"location":"Algo/Mathematics/fft.html#references","title":"References","text":"<ol> <li>The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever?</li> <li>Cooley\u2013Tukey FFT algorithm</li> </ol>"},{"location":"Algo/Mathematics/mobius.html","title":"Mobius Function","text":""},{"location":"Algo/Mathematics/mobius.html#code","title":"Code","text":"<pre><code>int mu[n], minD[n];\nvector&lt;int&gt; divs[n];\n\nvoid precalcDivs(int n) {\n  for (int d = 1; d &lt; n; d++) {\n    for (int v = d; v &lt; n; v+=d) {\n      divs[v].pb(d);\n    }\n  }\n\n  mu[1] = 1;\n\n  for (int d = 2; d &lt; n; d++) {\n    if (minD[d] == 0)\n      minD[d] = d;\n\n    if (minD[d] != minD[d / minD[d]])\n      mu[d] = -mu[d / minD[d]];\n\n    for (int v = 2 * d; v &lt; n; v+=d) {\n      if (minD[v] == 0)\n        minD[v] = d;\n    }\n  }\n}\n</code></pre>"},{"location":"Algo/Mathematics/mobius.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define pb push_back\n\nconst int n = 10;\n// mu = Mobius function\n// minD = smallest prime factor of a number\n// divs = list of divisors for each number\nint mu[n], minD[n];\nvector&lt;int&gt; divs[n];\n\nvoid precalcDivs(int n) {\n  // Store each number's divisors in divs array\n  for (int d = 1; d &lt; n; d++) {\n    for (int v = d; v &lt; n; v+=d) {\n      divs[v].pb(d);\n    }\n  }\n\n  // mo(1) = 1\n  mu[1] = 1;\n\n  for (int d = 2; d &lt; n; d++) {\n    // If minD[d] is still 0, it means d is a prime number\n    if (minD[d] == 0)\n      minD[d] = d;\n\n    // Determine the value of mu[d]:\n    // If d is divisible by its smallest prime factor more than once, mu[d] is 0 (as it's not square-free)\n    // Otherwise, mu[d] is -1 or 1 depending on the number of prime factors (calculated recursively)\n    if (minD[d] != minD[d / minD[d]])\n      mu[d] = -mu[d / minD[d]];\n\n    // Set the smallest prime factor for all multiples of d that haven't been assigned yet\n    for (int v = 2 * d; v &lt; n; v+=d) {\n      if (minD[v] == 0)\n        minD[v] = d;\n    }\n\n  }\n}\n\nint main() {\n  precalcDivs(n);\n\n  for (int i = 0; i&lt;n;i++) {\n    cout &lt;&lt; mu[i] &lt;&lt; \" \";\n  }\n  cout &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>"},{"location":"Algo/faq/bfs_insert_order.html","title":"BFS insert order","text":"<p>\u9019\u5169\u500b\u7248\u672c\u7684\u6df1\u5ea6\u512a\u5148\u641c\u7d22\uff08DFS\uff09\u51fd\u6578\u7684\u5dee\u7570\u5728\u65bc <code>comp.pb(v)</code>\uff08\u6216\u6dfb\u52a0\u5230 <code>comp</code> \u7684\u64cd\u4f5c\uff09\u7684\u4f4d\u7f6e\uff0c\u9019\u5f71\u97ff\u4e86\u641c\u7d22\u9806\u5e8f\u548c\u7d50\u679c\u3002</p>"},{"location":"Algo/faq/bfs_insert_order.html#_1","title":"\u7b2c\u4e00\u7a2e\u7248\u672c","text":"<pre><code>void dfs(int v) {\n  used[v] = true;\n  comp.pb(v);\n\n  for (auto to : g[v]) {\n    if (!used[to]) {\n      dfs(to);\n    }\n  }\n}\n</code></pre> <p>\u7279\u5fb5\uff1a</p> <ol> <li><code>comp.pb(v)</code> \u5728\u9032\u5165\u7bc0\u9ede <code>v</code> \u6642\u7acb\u5373\u57f7\u884c\u3002</li> <li>\u9019\u610f\u5473\u8457\u7bc0\u9ede <code>v</code> \u662f\u5728\u5b83\u7684\u9130\u5c45\u5c1a\u672a\u63a2\u7d22\u4e4b\u524d\u88ab\u52a0\u5165\u5230 <code>comp</code> \u4e2d\u3002</li> <li>\u7d50\u679c\u4e2d\uff0c\u7bc0\u9ede\u5c07\u6309 \u524d\u5e8f\u904d\u6b77\uff08pre-order traversal\uff09 \u7684\u9806\u5e8f\u5b58\u5132\uff0c\u9019\u662f DFS \u904d\u6b77\u7bc0\u9ede\u7684\u9806\u5e8f\u3002</li> </ol> <p>\u9069\u7528\u5834\u5408\uff1a\u5982\u679c\u4f60\u9700\u8981\u5728\u904d\u6b77\u904e\u7a0b\u4e2d\u5373\u6642\u8a18\u9304\u7bc0\u9ede\uff0c\u9019\u7a2e\u65b9\u5f0f\u66f4\u70ba\u5408\u9069\u3002</p>"},{"location":"Algo/faq/bfs_insert_order.html#_2","title":"\u7b2c\u4e8c\u7a2e\u7248\u672c","text":"<pre><code>void dfs(int v) {\n  used[v] = true;\n\n  for (auto to : g[v]) {\n    if (!used[to]) {\n      dfs(to);\n    }\n  }\n  comp.pb(v);\n}\n</code></pre> <p>\u7279\u5fb5\uff1a</p> <ol> <li><code>comp.pb(v)</code> \u5728\u7bc0\u9ede <code>v</code> \u7684\u6240\u6709\u9130\u5c45\u90fd\u63a2\u7d22\u5b8c\u6210\u5f8c\u624d\u57f7\u884c\u3002</li> <li>\u9019\u610f\u5473\u8457\u7bc0\u9ede <code>v</code> \u662f\u5728\u56de\u6eaf\u968e\u6bb5\u88ab\u52a0\u5165\u5230 <code>comp</code> \u4e2d\u3002</li> <li>\u7d50\u679c\u4e2d\uff0c\u7bc0\u9ede\u5c07\u6309 \u5f8c\u5e8f\u904d\u6b77\uff08post-order traversal\uff09 \u7684\u9806\u5e8f\u5b58\u5132\u3002</li> </ol> <p>\u9069\u7528\u5834\u5408\uff1a\u5982\u679c\u4f60\u9700\u8981\u5c0d\u7bc0\u9ede\u9032\u884c\u62d3\u64b2\u6392\u5e8f\u6216\u8655\u7406 DAG\uff08\u6709\u5411\u7121\u74b0\u5716\uff09\u4e2d\u7684\u4f9d\u8cf4\u95dc\u4fc2\uff0c\u9019\u7a2e\u65b9\u5f0f\u66f4\u70ba\u5408\u9069\u3002</p>"},{"location":"Algo/faq/bfs_insert_order.html#_3","title":"\u4e3b\u8981\u5dee\u7570\u5c0d\u6bd4","text":"\u7248\u672c <code>comp.pb(v)</code> \u7684\u57f7\u884c\u6642\u6a5f \u5b58\u5132\u9806\u5e8f \u9069\u7528\u60c5\u6cc1 \u7b2c\u4e00\u7a2e\uff08pre-order\uff09 \u9032\u5165\u7bc0\u9ede <code>v</code> \u6642 \u524d\u5e8f\u904d\u6b77\u9806\u5e8f \u5373\u6642\u8a18\u9304\u7bc0\u9ede \u7b2c\u4e8c\u7a2e\uff08post-order\uff09 \u96e2\u958b\u7bc0\u9ede <code>v</code> \u6642 \u5f8c\u5e8f\u904d\u6b77\u9806\u5e8f \u62d3\u64b2\u6392\u5e8f\u3001\u4f9d\u8cf4\u95dc\u4fc2\u8655\u7406\u7b49\u5834\u5408 <p>\u5982\u679c\u4f60\u9700\u8981\u5c0d\u5b58\u5132\u7684\u7d50\u679c\u6709\u7279\u5b9a\u9700\u6c42\uff08\u4f8b\u5982\u62d3\u64b2\u6392\u5e8f\u9700\u8981\u5f8c\u5e8f\uff09\uff0c\u61c9\u6839\u64da\u9700\u6c42\u9078\u64c7\u76f8\u61c9\u7684\u7248\u672c\u3002</p>"},{"location":"Algo/graphs/articulation_points.html","title":"Articulation points","text":"<p>Here's a example  graph:</p> <p></p> <p>Now we dfs it:</p> <p></p> <p>There are two back edges: $6$ to $3$ and $2$ to $1$.</p> <p>Update $low[u]$</p> <pre><code>low[u] = min(low[u], low[v]);\n</code></pre> <p>When DFS returns, we update $low[u]$. In the above graph, it's $6$ and $5$.</p> <p>Back edge handling</p> <pre><code>low[u] = min(low[u], disc[v]);\n</code></pre> <p>If <code>v</code> is already visited and is not the parent of <code>u</code>, we found a back edge. In the above graph, it's $6$ and $3$.</p>"},{"location":"Archlinux/archlinux_dual_boot.html","title":"Arch Linux Dual Boot with Windows 11","text":""},{"location":"Archlinux/archlinux_dual_boot.html#preparation-on-windows-11","title":"Preparation on Windows 11","text":"<p>We will install Windows 11 first, then Arch Linux.</p> <p>We need at least 512MB EFI partition in Arch Linux, so we will create a 1GB EFI system during Windows 11 Installation.</p> <p>Reference</p> <p>To create a 1GB EFI boot system:</p> <ol> <li>remove all the partitions</li> <li><code>shift + f10</code> to open cmd</li> </ol> <p>and then</p> <pre><code>diskpart\nlist disk\nsel disk 1\ncreate partition efi size=1024\nformat quick fs=fat32 label=System\nexit\n</code></pre> <p>and then keep installing Windows 11.</p>"},{"location":"Archlinux/archlinux_dual_boot.html#create-live-usb-for-arch-linux","title":"Create Live USB for Arch Linux","text":"<p>Now for Arch Linux.</p> <p>First, we need to allocate some space for Arch Linux, so we go to disk management, and shrink the Windows 11 we installed, like 200GB.</p> <p>and then create Live USB for Arch Linux, balenaEtcher</p> <p>When install Arch Linux, if you need wifi, type <code>iwctl</code></p> <pre><code>iwctl\ndevice list\nstation wlan0 scan\nstation wlan0 get-networks\nstation wlan0 connect IAN2\n</code></pre> <p>and then <code>ping google.com</code> to test</p>"},{"location":"Archlinux/archlinux_dual_boot.html#config-before-installation","title":"Config Before Installation","text":"<p>Note</p> <p>make terminal font bigger</p> <pre><code>cd /usr/share/kbd/consolefonts/\nsetfont ter-d20b.psf.gz\n</code></pre> <p>in <code>/etc/makepkg.conf</code></p> <pre><code>MAKEFLAGS=\"-j$(expr $(nproc) \\+ 1)\"\n</code></pre> <p>in <code>/etc/pacman.conf</code></p> <pre><code>Color\nParallelDownloads = 5\n</code></pre> <pre><code>[core]\nServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch\nInclude = /etc/pacman.d/mirrorlist\n\n[extra]\nServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch\nInclude = /etc/pacman.d/mirrorlist\n\n#[community-testing]\n#Include = /etc/pacman.d/mirrorlist\n\n[community]\nServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch\nInclude = /etc/pacman.d/mirrorlist\n</code></pre> <pre><code>pacman -Syy\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#partitioning","title":"Partitioning","text":"<pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\nnvme0n1     259:0    0 931.5G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0     1G  0 part /boot           # EFI System\n\u251c\u2500nvme0n1p2 259:2    0    16M  0 part\n\u251c\u2500nvme0n1p3 259:3    0 730.5G  0 part                 # Windows 11 Partition\n\u251c\u2500nvme0n1p4 259:4    0     8G  0 part [SWAP]          # Linux Swap\n\u2514\u2500nvme0n1p5 259:5    0   192G  0 part /               # Linux Partition\n</code></pre> <p>and use <code>cfdisk /dev/nvme0n1</code> to partition</p> <pre><code>mkswap /dev/nvme0n1p4\nswapon /dev/nvme0n1p4\nmkfs.ext4 /dev/nvme0n1p5\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#mount-the-file-systems","title":"Mount the file systems","text":"<pre><code>mount /dev/nvme0n1p5 /mnt\n</code></pre> <pre><code>mount --mkdir /dev/nvme0n1p1 /mnt/boot\n</code></pre> <pre><code>pacstrap /mnt base linux linux-firmware vim\n</code></pre> <pre><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab\narch-chroot /mnt\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#set-time-and-locale","title":"Set Time and Locale","text":"<pre><code>ln -sf /usr/share/zoneinfo/Asia/Taipei /etc/localtime\n</code></pre> <pre><code>vim /etc/locale.gen\n</code></pre> <pre><code># uncomment this line\nen_US.UTF-8 UTF-8\n</code></pre> <pre><code>locale-gen\necho LANG=en_US.UTF-8 &gt; /etc/locale.conf\n</code></pre> <p>the name is the computer's name</p> <pre><code>echo myarch &gt; /etc/hostname\n</code></pre> <pre><code>vim /etc/hosts\n</code></pre> <pre><code>127.0.0.1 localhost\n::1 localhost\n127.0.1.1 myarch\n</code></pre> <pre><code>passwd\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#install-grub-boot-loader","title":"Install Grub Boot Loader","text":"<pre><code>pacman -S grub efibootmgr os-prober networkmanager wireless_tools wpa_supplicant iwd\n</code></pre> <pre><code>systemctl enable NetworkManager\nsystemctl enable iwd\n</code></pre> <p>install grub:</p> <pre><code>grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB\n</code></pre> <p>in <code>/etc/default/grub</code>, uncomment (this can be done by archlinux_install script):</p> <pre><code>GRUB_DISABLE_OS_PROBER=false\n</code></pre> <p>Generate grub config:</p> <pre><code>grub-mkconfig -o /boot/grub/grub.cfg\n</code></pre> <p>Note</p> <p>After we reboot, we may see that there's no windows 11 option on grub menu, just log in Arch Linux, and type:</p> <pre><code>sudo grub-mkconfig -o /boot/grub/grub.cfg\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#add-user","title":"Add User","text":"<p>the name is the user's name</p> <pre><code>pacman -S sudo\nuseradd -m ian\npasswd ian\n</code></pre> <pre><code>usermod -aG wheel,audio,video,storage ian\n</code></pre> <pre><code>EDITOR=vim visudo\n</code></pre> <p>uncomment this line</p> <pre><code>## Uncomment to allow members of group wheel to execute any command\n%wheel ALL=(ALL:ALL) ALL\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#finish-arch-linux-installation","title":"Finish Arch Linux Installation","text":"<pre><code>exit\n</code></pre> <pre><code>umount /mnt\n</code></pre> <p>or</p> <pre><code>umount -l /mnt\n</code></pre> <pre><code>shutdown now\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#after-installation","title":"After Installation","text":"<p>connect wifi with <code>nmtui</code> or <code>iwctl</code></p> <p>After Installation</p> <p>config terminal fonts</p> <pre><code>sudo pacman -S terminus-font\ncd /usr/share/kbd/consolefonts/\nsetfont ter-d20b.psf.gz\n</code></pre> <p>in <code>/etc/vconsole.conf</code></p> <pre><code>FONT=ter-d20b.psf.gz\n</code></pre> <p>in <code>/etc/makepkg.conf</code></p> <pre><code>MAKEFLAGS=\"-j$(expr $(nproc) \\+ 1)\"\n</code></pre> <p>in <code>/etc/pacman.conf</code></p> <pre><code>Color\nParallelDownloads = 5\n</code></pre> <pre><code>[core]\nServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch\nInclude = /etc/pacman.d/mirrorlist\n\n[extra]\nServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch\nInclude = /etc/pacman.d/mirrorlist\n\n#[community-testing]\n#Include = /etc/pacman.d/mirrorlist\n\n[community]\nServer = http://archlinux.cs.nctu.edu.tw/$repo/os/$arch\nInclude = /etc/pacman.d/mirrorlist\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#install-yay-aur-helper","title":"Install Yay AUR Helper","text":"<pre><code>sudo pacman -Syy\n</code></pre> <p>copy github ip to <code>/etc/hosts</code>:</p> <pre><code>140.82.114.3 github.com\n</code></pre> <pre><code>sudo pacman -S base-devel git\ngit clone https://aur.archlinux.org/yay.git\ncd yay\nmakepkg -si\n</code></pre>"},{"location":"Archlinux/archlinux_dual_boot.html#install-user-packages","title":"Install User Packages","text":"<pre><code>git clone https://github.com/zyrethor/archlinux_install\ncd archlinux_install\n./install.sh ## default install packages\n./install.sh -s ## install system settings\n./install.sh -a ## install additional packages\n./install.sh -vm ## install vmware packages, after installation, reboot\n</code></pre> <p>If the installation takes too long, then lengthen sudo timeout, for example 60 min:</p> <pre><code>sudo EDITOR=vim visudo\n\nDefaults env_reset, timestamp_timeout=60\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html","title":"Arch Linux Tips","text":""},{"location":"Archlinux/archlinux_tips.html#wifi","title":"Wifi","text":"<p>After installed Arch Linux, you can use <code>iwd</code> or <code>nmtui</code> to connect wifi.</p>"},{"location":"Archlinux/archlinux_tips.html#customize-grub","title":"Customize Grub","text":"<pre><code>sudo vim /etc/default/grub\nGRUB_GFXMODE=1024x768\n</code></pre> <pre><code>git clone https://github.com/vinceliuice/grub2-themes.git\ncd grub2-themes\nsudo ./install.sh -t stylish -s 2k\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#vmware","title":"Vmware","text":"<pre><code>sudo systemctl start vmware-networks-configuration.service\nsudo systemctl start vmware-networks.service\nsudo modprobe -a vmw_vmci vmmon\n\n\nsudo pacman -S open-vm-tools xf86-video-vmware xf86-input-vmmouse\nsudo systemctl enable vmtoolsd.service vmware-vmblock-fuse.service\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#install-fish","title":"Install Fish","text":"<pre><code>curl https://raw.githubusercontent.com/oh-my-fish/oh-my-fish/master/bin/install | fish\nomf theme\nomf install eclm\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#install-zsh","title":"Install Zsh","text":"<pre><code>sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#neovim","title":"Neovim","text":"<pre><code>curl -sL https://raw.githubusercontent.com/jorgebucaran/fisher/main/functions/fisher.fish | source &amp;&amp; fisher install jorgebucaran/fisher\nfisher install jorgebucaran/nvm.fish\n\nnvm install 18\nnvm use 18\nnpm install -g tree-sitter-cli\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#vim","title":"Vim","text":"<pre><code>curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\\\\\n    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\n\ncd ~/.vim/plugged/youcompleteme\n./install.py --clang-completer\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#link-sh-to-bash","title":"Link sh to bash","text":"<pre><code>ls -l /bin/sh\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#sudo-timeout","title":"Sudo Timeout","text":"<p>lengthen sudo timeout, for example 60 min <pre><code>sudo visudo\n\nDefaults env_reset, timestamp_timeout=60\n</code></pre></p>"},{"location":"Archlinux/archlinux_tips.html#change-chrome-font","title":"Change Chrome Font","text":"Type Font Standard font Arial Serif font Arial Sans-serif font Arial Fixed-width font Noto Sans Mono CJK TC Mathematical font Noto Sans Mono CJK TC"},{"location":"Archlinux/archlinux_tips.html#chezmoi","title":"Chezmoi","text":"<pre><code>chezmoi --init apply zyrethor\n\nchezmoi update\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#error-gpgme-error-no-data","title":"error: GPGME error: No data","text":"<p><pre><code>sudo rm -r /var/lib/pacman/sync/\n</code></pre> resource</p>"},{"location":"Archlinux/archlinux_tips.html#neovim-different-indent","title":"Neovim different indent","text":"<pre><code>:set expandtab\n:retab\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#remove-serial-number-in-filename-notion-backup","title":"remove serial number in filename (notion backup)","text":"<pre><code>file:\nfind . -type f -name \"*.md\" -exec perl-rename 's/ [0-9a-z]{32}//' {} +\n\nfolder:\n#!/bin/bash\nfind . -type d -name \"* *\" | sort -r | while read -r dir; do\n  newdir=$(echo \"$dir\" | sed 's/ [0-9a-z]{32}//')\n  mv \"$dir\" \"$newdir\"\ndone\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#chmod","title":"chmod","text":"<p>only directories</p> <pre><code>find * -type d -exec chmod 755 {} +\n</code></pre> <p>only files</p> <pre><code>find * -type f -exec chmod 644 {} +\n</code></pre> <p>use fd to batch process, use <code>-X</code> instead of <code>-x</code></p> <pre><code>fd -t d -X chmod 755 {}\n</code></pre> <pre><code>fd -t f -X chmod 644 {}\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#convert-video-format","title":"Convert Video Format","text":"<pre><code>ffmpeg -i test.webm -c copy test.mp4\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#yt-dlp","title":"yt-dlp","text":"<p>download only audio</p> <pre><code>yt-dlp --extract-audio 'https://www.youtube.com/watch?v='\n</code></pre> <p>it will select opus format (default)</p> <p>if you want to select differnt format, use <code>--audio-format</code></p> <p>download only mp3</p> <pre><code>yt-dlp --extract-audio --audio-format mp3 'https://www.youtube.com/watch?v='\n</code></pre>"},{"location":"Archlinux/archlinux_tips.html#repeat-key-speed","title":"Repeat Key Speed","text":"<p>in <code>~/.xinitrc</code></p> <p>xset r rate [delay] [rate]</p> <pre><code>xset r rate 200 20\n</code></pre>"},{"location":"CSES/graphs/When%20to%20use.html","title":"When to use algorithms","text":"<ul> <li> <p>Use Topological Sort when dealing with DAGs to find the shortest path efficiently.</p> </li> <li> <p>Use BFS for finding the shortest path in terms of the number of edges in unweighted graphs.</p> </li> <li> <p>Use Dijkstra's Algorithm for finding the shortest path in weighted graphs without negative weights.</p> </li> <li> <p>Use Bellman-Ford when dealing with weighted graphs that may contain negative weights but no negative cycles.</p> </li> </ul>"},{"location":"CSES/graphs/course_schedule.html","title":"Course Schedule","text":"<p>Solution: Topological order</p> <p>Time Complexity: $O(V+E)$</p>"},{"location":"CSES/graphs/course_schedule.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  int a, b;\n\n  vector&lt;vector&lt;int&gt;&gt; adj(n+1);\n  vector&lt;int&gt; in_degree(n+1);\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b;\n    adj[a].pb(b);\n    in_degree[b]++;\n  }\n\n  queue&lt;int&gt; q;\n  for (int i = 1; i &lt;= n; i++) {\n    if (in_degree[i] == 0)\n      q.push(i);\n  }\n\n  vector&lt;int&gt; ans;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    ans.pb(u);\n    for (auto &amp; to : adj[u]) {\n      in_degree[to]--;\n      if (in_degree[to] == 0)\n        q.push(to);\n    }\n  }\n\n  int len = ans.size();\n  if (len == n) {\n    for (int i = 0; i &lt; len; i++) {\n      cout &lt;&lt; ans[i] &lt;&lt; (i == len-1 ? \"\\n\" : \" \");\n    }\n  }\n  else {\n    cout &lt;&lt; \"IMPOSSIBLE\";\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/course_schedule.html#code-with-comment","title":"Code with comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Define macros for convenience\n#define ll long long            // Shorthand for 'long long'\n#define pb emplace_back        // Shorthand for 'emplace_back' method of vectors\n#define pii pair&lt;ll, int&gt;       // Shorthand for a pair consisting of 'long long' and 'int'\nconst ll INF = 1e18;             // A large constant value, often used as infinity\n\nint main() {\n    // Optimize I/O operations\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m; // 'n' = number of vertices, 'm' = number of edges\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int a, b; // Variables to store edge information\n\n    // Initialize adjacency list and in-degree array\n    // Using (n + 1) to make the vertex indexing 1-based\n    vector&lt;vector&lt;int&gt;&gt; adj(n + 1, vector&lt;int&gt;()); // Adjacency list\n    vector&lt;int&gt; in_degree(n + 1, 0);              // In-degree of each vertex\n\n    // Read all edges and build the adjacency list and in-degree array\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; a &gt;&gt; b;    // Read edge from vertex 'a' to vertex 'b'\n        adj[a].pb(b);    // Add 'b' to the adjacency list of 'a'\n        in_degree[b]++;   // Increment the in-degree of vertex 'b'\n    }\n\n    queue&lt;int&gt; q; // Queue to store vertices with zero in-degree\n\n    // Enqueue all vertices with zero in-degree\n    for (int i = 1; i &lt;= n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    vector&lt;int&gt; ans; // Vector to store the topological order\n\n    // Perform Kahn's Algorithm for Topological Sorting\n    while (!q.empty()) {\n        int u = q.front(); // Get the vertex at the front of the queue\n        q.pop();           // Remove it from the queue\n\n        ans.pb(u);         // Add the vertex to the topological order\n\n        // Iterate through all adjacent vertices of 'u'\n        for (auto &amp;to : adj[u]) {\n            in_degree[to]--; // Decrement the in-degree as 'u' is processed\n\n            // If in-degree becomes zero, enqueue the vertex\n            if (in_degree[to] == 0) {\n                q.push(to);\n            }\n        }\n    }\n\n    // Check if topological sorting was possible (i.e., no cycles)\n    if (ans.size() == n) {\n        // If possible, print the topological order\n        for (int i = 0; i &lt; ans.size(); i++) {\n            cout &lt;&lt; ans[i];\n            if (i != ans.size() - 1)\n                cout &lt;&lt; \" \"; // Add space between numbers except after the last one\n            else\n                cout &lt;&lt; \"\\n\"; // Add a newline after the last number\n        }\n    }\n    else {\n        // If not possible (due to a cycle), print \"IMPOSSIBLE\"\n        cout &lt;&lt; \"IMPOSSIBLE\";\n    }\n\n    return 0; // Indicate successful termination\n}\n</code></pre>"},{"location":"CSES/graphs/cycle_finding.html","title":"Cycle Finding","text":"<p>Solution: Bellman-Ford algorithm</p> <p>Time Complexity: $O(V \\times E)$</p>"},{"location":"CSES/graphs/cycle_finding.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n\n  struct Edge {\n    int a, b;\n    ll w;\n  };\n\n  vector&lt;Edge&gt; ed(m);\n\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; ed[i].a &gt;&gt; ed[i].b &gt;&gt; ed[i].w;\n  }\n\n\n  vector&lt;ll&gt; dist(n+1, 0);\n  vector&lt;int&gt; pred(n+1, -1);\n  dist[0] = 0;\n  int x = -1;\n\n  for (int i= 1; i &lt;= n; i++) {\n    x = -1;\n    for (auto&amp; e : ed) {\n      if (dist[e.b] &gt; dist[e.a] + e.w) {\n        dist[e.b] = dist[e.a] + e.w;\n        pred[e.b] = e.a;\n        x = e.b;\n      }\n    }\n  }\n\n  if (x == -1) {\n    cout &lt;&lt; \"NO\\n\";\n    return 0;\n  }\n\n  for (int i = 0; i &lt; n; i++) {\n    x = pred[x];\n  }\n\n  int start = x;\n  vector&lt;int&gt; cycle;\n  cycle.pb(start);\n  x = pred[start];\n  while (x != start) {\n    cycle.pb(x);\n    x = pred[x];\n  }\n\n  cycle.pb(start);\n  reverse(cycle.begin(), cycle.end());\n  cout &lt;&lt; \"YES\\n\";\n  int len = cycle.size();\n  for (int i = 0; i &lt; len; i++) {\n    cout &lt;&lt; cycle[i] &lt;&lt; (i == len - 1 ? \"\\n\" : \" \");\n  }\n\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/cycle_finding.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\nconst ll INF = 1e18;\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m; // Read number of nodes and edges\n\n    // Define the Edge structure to store edge information\n    struct Edge {\n        int a;    // Starting node of the edge\n        int b;    // Ending node of the edge\n        ll w;     // Weight of the edge\n    };\n\n    vector&lt;Edge&gt; ed(m); // Edge list to store all edges\n\n    // Read all edges and store them in the edge list\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; ed[i].a &gt;&gt; ed[i].b &gt;&gt; ed[i].w; // Read edge from a to b with weight w\n    }\n\n    // Initialize distance and predecessor arrays\n    // dist[i]: minimum distance to node i\n    // pred[i]: predecessor of node i in the shortest path\n    vector&lt;ll&gt; dist(n + 1, INF);\n    vector&lt;int&gt; pred(n + 1, -1);\n    dist[0] = 0; // Node numbering starts from 1, so dist[0] is unused\n    int x = -1;   // Variable to store the node updated in the last iteration\n\n    // Perform Bellman-Ford algorithm for n iterations\n    for (int i = 1; i &lt;= n; i++) {\n        x = -1; // Reset x at the start of each iteration\n        for (auto&amp; e : ed) {\n            // Relax the edge if a shorter path is found\n            if (dist[e.a] != INF &amp;&amp; dist[e.b] &gt; dist[e.a] + e.w) {\n                dist[e.b] = dist[e.a] + e.w; // Update distance\n                pred[e.b] = e.a;             // Update predecessor\n                x = e.b;                      // Mark node b as updated\n            }\n        }\n    }\n\n    // After n iterations, check if any distance was updated\n    if (x == -1) {\n        // No updates in the nth iteration implies no negative cycle\n        cout &lt;&lt; \"NO\\n\";\n        return 0;\n    }\n\n    // To find the actual negative cycle, we need to backtrack\n    // Start from the last updated node and follow predecessors\n    for (int i = 0; i &lt; n; i++) {\n        x = pred[x]; // Move back n steps to ensure we are within the cycle\n    }\n\n    int start = x; // Starting node of the cycle\n    vector&lt;int&gt; cycle; // Vector to store the cycle nodes\n    cycle.pb(start);   // Add the starting node to the cycle\n    x = pred[start];   // Move to the predecessor of the start node\n\n    // Traverse the cycle until we return to the start node\n    while (x != start) {\n        cycle.pb(x);   // Add node to the cycle\n        x = pred[x];   // Move to the predecessor\n    }\n\n    cycle.pb(start); // Complete the cycle by adding the start node again\n    reverse(cycle.begin(), cycle.end()); // Reverse to get the correct order\n\n    // Output the cycle\n    cout &lt;&lt; \"YES\\n\";\n    int len = cycle.size();\n    for (int i = 0; i &lt; len; i++) {\n        cout &lt;&lt; cycle[i] &lt;&lt; (i == len - 1 ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/flight_discount.html","title":"Flight Discount","text":"<p>Solution: Dijkstra's algorithm</p> <p>Time Complexity: $O((V+E) \\log (V))$</p>"},{"location":"CSES/graphs/flight_discount.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n#define pii pair&lt;int, int&gt;\n#define tp tuple&lt;ll, int, int&gt;\n\nconst ll INF = 1e18;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  int a, b, c;\n\n  vector&lt;vector&lt;pii&gt;&gt; adj(n+1);\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    adj[a].emplace_back(b, c);\n  }\n\n  vector&lt;ll&gt; d0(n+1, INF);\n  vector&lt;ll&gt; d1(n+1, INF);\n  d0[1] = 0;\n\n  // pq&lt;cost, node, state&gt;\n  priority_queue&lt;tp, vector&lt;tp&gt;, greater&lt;tp&gt;&gt; pq;\n  pq.emplace(0, 1, 0);\n  while (!pq.empty()) {\n    auto [cost, v, state] = pq.top();\n    pq.pop();\n\n    if (state == 0 &amp;&amp; cost &gt; d0[v]) continue;\n    if (state == 1 &amp;&amp; cost &gt; d1[v]) continue;\n\n    for (auto&amp; [to, weight] : adj[v]) {\n      ll w = (ll)weight;\n      if (state == 0) {\n        if (d0[to] &gt; d0[v] + w) {\n          d0[to] = d0[v] + w;\n          pq.emplace(d0[to], to, 0);\n        }\n\n        ll new_cost = d0[v] + w / 2;\n        if (d1[to] &gt; new_cost) {\n          d1[to] = new_cost;\n          pq.emplace(d1[to], to, 1);\n        }\n      }\n      else {\n        if (d1[to] &gt; d1[v] + w) {\n          d1[to] = d1[v] + w;\n          pq.emplace(d1[to], to, 1);\n        }\n\n      }\n    }\n  }\n\n  cout &lt;&lt; min(d0[n], d1[n]);\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/flight_discount.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pb push_back\n#define pii pair&lt;int, int&gt;\n#define tp tuple&lt;ll, int, int&gt;\n\nconst ll INF = 1e18;\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m; // Read number of nodes and edges\n\n    int a, b, c;\n\n    // Adjacency list where adj[u] contains pairs (v, w)\n    // representing an edge from u to v with weight w\n    vector&lt;vector&lt;pii&gt;&gt; adj(n + 1, vector&lt;pii&gt;());\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;       // Read edge from a to b with weight c\n        adj[a].emplace_back(b, c); // Add edge to adjacency list\n    }\n\n    // Initialize distance arrays\n    // d0[i]: minimum cost to reach node i without using the discount\n    // d1[i]: minimum cost to reach node i after using the discount\n    vector&lt;ll&gt; d0(n + 1, INF);\n    vector&lt;ll&gt; d1(n + 1, INF);\n    d0[1] = 0; // Starting node has a distance of 0 without discount\n\n    // Priority queue to select the next node with the smallest cost\n    // Each entry is a tuple (cost, node, state)\n    // state: 0 -&gt; discount not used, 1 -&gt; discount used\n    priority_queue&lt;tp, vector&lt;tp&gt;, greater&lt;tp&gt;&gt; pq;\n    pq.emplace(0, 1, 0); // Start with node 1, cost 0, discount not used\n\n    while (!pq.empty()) {\n        auto [cost, v, state] = pq.top(); // Current state\n        pq.pop();\n\n        // Skip processing if we have already found a better path\n        if (state == 0 &amp;&amp; cost &gt; d0[v]) continue;\n        if (state == 1 &amp;&amp; cost &gt; d1[v]) continue;\n\n        // Iterate over all outgoing edges from node v\n        for (auto&amp; [to, weight] : adj[v]) {\n            ll w = static_cast&lt;ll&gt;(weight); // Convert weight to long long\n\n            if (state == 0) { // Discount not used yet\n                // Case 1: Do not use the discount on this edge\n                if (d0[to] &gt; d0[v] + w) {\n                    d0[to] = d0[v] + w;       // Update distance without discount\n                    pq.emplace(d0[to], to, 0); // Push to queue with state 0\n                }\n\n                // Case 2: Use the discount on this edge\n                // The discount reduces the weight by half\n                ll new_cost = d0[v] + w / 2;\n                if (d1[to] &gt; new_cost) {\n                    d1[to] = new_cost;          // Update distance with discount used\n                    pq.emplace(d1[to], to, 1);  // Push to queue with state 1\n                }\n            }\n            else { // state == 1, discount has already been used\n                // Only option is to traverse the edge without discount\n                if (d1[to] &gt; d1[v] + w) {\n                    d1[to] = d1[v] + w;       // Update distance after discount\n                    pq.emplace(d1[to], to, 1); // Push to queue with state 1\n                }\n            }\n        }\n    }\n\n    // The minimum cost to reach node n is the minimum of d0[n] and d1[n]\n    cout &lt;&lt; min(d0[n], d1[n]);\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/flight_routes.html","title":"Flight Routes","text":"<p>Solution: Dijkstra's algorithm</p> <p>Time Complexity: $O(k \\times E \\times \\log V)$</p>"},{"location":"CSES/graphs/flight_routes.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m, k;\n  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n  int a, b;\n  ll c;\n\n  vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; adj(n+1);\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    adj[a].emplace_back(b, c);\n  }\n\n  vector&lt;int&gt; count(n+1, 0);\n  vector&lt;ll&gt; ans;\n  priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;\n  pq.emplace(0, 1);\n\n  while (!pq.empty()) {\n    auto [cost, u] = pq.top();\n    pq.pop();\n\n    if (count[u] &gt;= k)\n      continue;\n\n    count[u]++;\n\n    if (u == n) {\n      ans.pb(cost);\n      if ((int)ans.size() == k)\n        break;\n    }\n\n    for (auto&amp; [to, w] : adj[u]) {\n      if (count[to] &lt; k)\n        pq.emplace(cost + w, to);\n    }\n\n  }\n\n  for (int i = 0; i &lt; k; i++) {\n    cout &lt;&lt; ans[i] &lt;&lt; (i == k-1 ? \"\\n\" : \" \");\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/flight_routes.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\n\n// Define a large constant to represent infinity\nconst ll INF = 1e18;\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; // Read number of nodes, edges, and the value of k\n\n    int a, b;\n    ll c;\n\n    // Adjacency list where adj[u] contains pairs (v, w)\n    // representing an edge from u to v with weight w\n    vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; adj(n + 1);\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;           // Read edge from a to b with weight c\n        adj[a].emplace_back(b, c);    // Add edge to adjacency list\n    }\n\n    // Array to keep track of how many times each node has been reached\n    vector&lt;int&gt; count(n + 1, 0);\n\n    // Vector to store the costs of the first k shortest paths to node n\n    vector&lt;ll&gt; ans;\n\n    // Priority queue (min-heap) to store pairs of (cost, node)\n    // The priority queue orders elements based on the smallest cost first\n    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;\n\n    // Initialize the priority queue with the starting node (1) and cost 0\n    pq.emplace(0, 1);\n\n    // Main loop to process nodes from the priority queue\n    while (!pq.empty()) {\n        auto [cost, u] = pq.top(); // Extract the node with the smallest cost\n        pq.pop();\n\n        // If the node has already been reached k times, skip it\n        if (count[u] &gt;= k)\n            continue;\n\n        // Increment the count for this node\n        count[u]++;\n\n        // If the destination node is reached, record the path cost\n        if (u == n) {\n            ans.pb(cost);             // Add the current path cost to the answer list\n            if ((int)ans.size() == k) // If k paths have been found, terminate the loop\n                break;\n        }\n\n        // Explore all adjacent edges from the current node\n        for (auto&amp; [to, w] : adj[u]) {\n            // If the adjacent node hasn't been reached k times yet, enqueue it\n            if (count[to] &lt; k)\n                pq.emplace(cost + w, to); // Add the new path with updated cost to the queue\n        }\n    }\n\n    // After finding k paths, output their costs\n    for (int i = 0; i &lt; k; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; (i == k - 1 ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/high_score.html","title":"High Score","text":"<p>Solution: Bellman-Ford algorithm</p> <p>Time Complexity: $O(V \\times E)$</p>"},{"location":"CSES/graphs/high_score.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n\n  struct Edge {\n    int a, b;\n    ll w;\n  };\n\n  vector&lt;Edge&gt; ed(m);\n  vector&lt;vector&lt;int&gt;&gt; adj(n+1, vector&lt;int&gt;());\n  vector&lt;vector&lt;int&gt;&gt; rv_adj(n+1, vector&lt;int&gt;());\n\n  // adj list\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; ed[i].a &gt;&gt; ed[i].b &gt;&gt; ed[i].w;\n    adj[ed[i].a].pb(ed[i].b);\n    rv_adj[ed[i].b].pb(ed[i].a);\n  }\n\n  // bfs\n  queue&lt;int&gt; q;\n\n  vector&lt;bool&gt; reach_from_start(n+1, false);\n  q.push(1);\n  reach_from_start[1] = true;\n  while (!q.empty()) {\n    int v = q.front();\n    q.pop();\n\n    for (auto&amp; to : adj[v]) {\n      if (!reach_from_start[to]) {\n        reach_from_start[to] = true;\n        q.push(to);\n      }\n    }\n  }\n\n  vector&lt;bool&gt; reach_to_end(n+1, false);\n  q.push(n);\n  reach_to_end[n] = true;\n  while (!q.empty()) {\n    int v = q.front();\n    q.pop();\n\n    for (auto&amp; to : rv_adj[v]) {\n      if (!reach_to_end[to]) {\n        reach_to_end[to] = true;\n        q.push(to);\n      }\n    }\n  }\n\n  vector&lt;int&gt; relevant(n+1, false);\n  for (int v = 1; v &lt;= n; v++) {\n    if (reach_from_start[v] &amp;&amp; reach_to_end[v])\n      relevant[v] = true;\n  }\n\n  // dp\n  const ll NEG_INF = -1e18;\n  vector&lt;ll&gt; dp(n+1, NEG_INF);\n  dp[1] = 0;\n  for (int i = 1; i &lt;= n-1; i++) {\n    bool updated = false;\n\n    for (auto&amp; e : ed) {\n      if (relevant[e.a] &amp;&amp; relevant[e.b]) {\n        if (dp[e.a] != NEG_INF &amp;&amp; dp[e.b] &lt; dp[e.a] + e.w) {\n          dp[e.b] = dp[e.a] + e.w;\n          updated = true;\n        }\n      }\n    }\n\n    if (!updated)\n      break;\n  }\n\n  bool has_cycle = false;\n  for (auto&amp; e : ed) {\n    if (relevant[e.a] &amp;&amp; relevant[e.b]) {\n      if (dp[e.a] != NEG_INF &amp;&amp; dp[e.b] &lt; dp[e.a] + e.w) {\n        has_cycle = true;\n        break;\n      }\n    }\n  }\n\n  if (has_cycle)\n    cout &lt;&lt; \"-1\\n\";\n  else\n    cout &lt;&lt; dp[n] &lt;&lt; \"\\n\";\n\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/high_score.html#code-with-comment","title":"Code with  Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pb push_back\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m; // Read number of nodes and edges\n\n    // Define the Edge structure to store edge information\n    struct Edge {\n        int a;   // Starting node of the edge\n        int b;   // Ending node of the edge\n        ll w;    // Weight of the edge\n    };\n\n    vector&lt;Edge&gt; ed(m); // Edge list to store all edges\n    vector&lt;vector&lt;int&gt;&gt; adj(n + 1, vector&lt;int&gt;());      // Adjacency list for the original graph\n    vector&lt;vector&lt;int&gt;&gt; rv_adj(n + 1, vector&lt;int&gt;());   // Adjacency list for the reverse graph\n\n    // Read all edges and build the adjacency lists\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; ed[i].a &gt;&gt; ed[i].b &gt;&gt; ed[i].w; // Read edge from a to b with weight w\n        adj[ed[i].a].pb(ed[i].b);             // Add b to the adjacency list of a\n        rv_adj[ed[i].b].pb(ed[i].a);          // Add a to the reverse adjacency list of b\n    }\n\n    // BFS to determine all nodes reachable from the start node (node 1)\n    queue&lt;int&gt; q;\n    vector&lt;bool&gt; reach_from_start(n + 1, false); // Boolean array to mark reachable nodes from start\n    q.push(1);                                   // Start BFS from node 1\n    reach_from_start[1] = true;                  // Mark start node as reachable\n\n    while (!q.empty()) {\n        int v = q.front(); // Current node\n        q.pop();\n\n        // Iterate over all neighbors of the current node\n        for (auto&amp; to : adj[v]) {\n            if (!reach_from_start[to]) { // If the neighbor hasn't been visited\n                reach_from_start[to] = true; // Mark as reachable\n                q.push(to);                  // Add to the queue for further exploration\n            }\n        }\n    }\n\n    // BFS to determine all nodes that can reach the end node (node n) using the reverse graph\n    vector&lt;bool&gt; reach_to_end(n + 1, false); // Boolean array to mark nodes that can reach end\n    q.push(n);                                // Start BFS from node n\n    reach_to_end[n] = true;                   // Mark end node as reachable to itself\n\n    while (!q.empty()) {\n        int v = q.front(); // Current node\n        q.pop();\n\n        // Iterate over all predecessors of the current node in the original graph\n        for (auto&amp; to : rv_adj[v]) {\n            if (!reach_to_end[to]) { // If the predecessor hasn't been visited\n                reach_to_end[to] = true; // Mark as able to reach end\n                q.push(to);               // Add to the queue for further exploration\n            }\n        }\n    }\n\n    // Determine relevant nodes that are both reachable from start and can reach end\n    vector&lt;int&gt; relevant(n + 1, false); // 1-based indexing; 0 is unused\n    for (int v = 1; v &lt;= n; v++) {\n        if (reach_from_start[v] &amp;&amp; reach_to_end[v])\n            relevant[v] = true; // Mark as relevant if both conditions are met\n    }\n\n    // Dynamic Programming (DP) array to store maximum path sums\n    const ll NEG_INF = -1e18;                   // Define negative infinity\n    vector&lt;ll&gt; dp(n + 1, NEG_INF);             // Initialize all distances to negative infinity\n    dp[1] = 0;                                 // Distance to start node is 0\n\n    // Perform edge relaxation for (n-1) iterations to compute maximum path sums\n    for (int i = 1; i &lt;= n - 1; i++) {\n        bool updated = false; // Flag to check if any update occurs in this iteration\n\n        // Iterate over all edges to perform relaxation\n        for (auto&amp; e : ed) {\n            // Only consider edges between relevant nodes\n            if (relevant[e.a] &amp;&amp; relevant[e.b]) {\n                // If the starting node has been reached and updating gives a better path\n                if (dp[e.a] != NEG_INF &amp;&amp; dp[e.b] &lt; dp[e.a] + e.w) {\n                    dp[e.b] = dp[e.a] + e.w; // Update the maximum path sum to node b\n                    updated = true;           // Mark that an update has occurred\n                }\n            }\n        }\n\n        // If no updates occurred in this iteration, no further improvements are possible\n        if (!updated)\n            break;\n    }\n\n    // After (n-1) iterations, check for the presence of positive weight cycles\n    bool has_cycle = false;\n    for (auto&amp; e : ed) {\n        if (relevant[e.a] &amp;&amp; relevant[e.b]) {\n            // If further relaxation is possible, a positive cycle exists\n            if (dp[e.a] != NEG_INF &amp;&amp; dp[e.b] &lt; dp[e.a] + e.w) {\n                has_cycle = true; // Positive cycle detected\n                break;\n            }\n        }\n    }\n\n    // Output the result based on the presence of a positive cycle\n    if (has_cycle)\n        cout &lt;&lt; \"-1\\n\";          // Output -1 if a positive cycle exists\n    else\n        cout &lt;&lt; dp[n] &lt;&lt; \"\\n\";   // Output the maximum path sum to node n\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/investigation.html","title":"Investigation","text":"<p>Solution: Dijkstra's algorithm</p> <p>Time Complexity: $O(E \\log V)$</p>"},{"location":"CSES/graphs/investigation.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\nconst int MOD = 1e9+7;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  int a, b, w;\n\n  vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(n+1);\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;\n    adj[a].pb(b, w);\n  }\n\n  vector&lt;ll&gt; dist(n+1, INF);\n  vector&lt;ll&gt; ways(n+1, 0);\n  vector&lt;int&gt; min_flights(n+1, 1e9);\n  vector&lt;int&gt; max_flights(n+1, 0);\n\n  dist[1] = 0;\n  ways[1] = 1;\n  min_flights[1] = 0;\n  max_flights[1] = 0;\n\n  priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;\n  pq.emplace(0, 1);\n\n  while (!pq.empty()) {\n    auto [cur_dist, u] = pq.top();\n    pq.pop();\n\n    if (cur_dist &gt; dist[u]) continue;\n\n    for (auto&amp; [to, w] : adj[u]) {\n      if (dist[to] &gt; dist[u] + w) {\n        dist[to] = dist[u] + w;\n        ways[to] = ways[u];\n        min_flights[to] = min_flights[u] + 1;\n        max_flights[to] = max_flights[u] + 1;\n        pq.emplace(dist[to], to);\n      }\n      else if (dist[to] == dist[u] + w) {\n        ways[to] = (ways[to] + ways[u]) % MOD;\n        min_flights[to] = min(min_flights[to], min_flights[u] + 1);\n        max_flights[to] = max(max_flights[to], max_flights[u] + 1);\n      }\n    }\n  }\n\n  cout &lt;&lt; dist[n] &lt;&lt; \" \" &lt;&lt; ways[n] &lt;&lt; \" \" &lt;&lt; min_flights[n] &lt;&lt; \" \" &lt;&lt; max_flights[n];\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/investigation.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\n\n// Constants\nconst int MOD = 1e9 + 7; // Modulo value for large numbers\nconst ll INF = 1e18;      // Representation of infinity\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; // Read number of nodes, edges, and the value of k\n\n    int a, b;\n    ll c;\n\n    // Adjacency list where adj[u] contains pairs (v, w)\n    // representing an edge from u to v with weight w\n    vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; adj(n + 1);\n    for (int i = 0; i &lt; m; i++) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;           // Read edge from a to b with weight c\n        adj[a].emplace_back(b, c);    // Add edge to adjacency list\n    }\n\n    // Initialize distance, ways, min_flights, and max_flights arrays\n    vector&lt;ll&gt; dist(n + 1, INF);          // Shortest distance from node 1 to each node\n    vector&lt;ll&gt; ways(n + 1, 0);            // Number of shortest paths to each node\n    vector&lt;int&gt; min_flights(n + 1, 1e9);  // Minimum number of flights to each node\n    vector&lt;int&gt; max_flights(n + 1, 0);    // Maximum number of flights to each node\n\n    // Starting node initialization\n    dist[1] = 0;           // Distance to itself is zero\n    ways[1] = 1;           // One way to reach itself\n    min_flights[1] = 0;   // Zero flights to reach itself\n    max_flights[1] = 0;   // Zero flights to reach itself\n\n    // Priority queue (min-heap) to store pairs (cost, node)\n    // The priority queue orders elements based on the smallest cost first\n    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;\n    pq.emplace(0, 1); // Start with node 1 and cost 0\n\n    // Main loop to process nodes from the priority queue\n    while (!pq.empty()) {\n        auto [cur_dist, u] = pq.top(); // Extract node with smallest cost\n        pq.pop();\n\n        // If the current distance is greater than the recorded distance, skip processing\n        if (cur_dist &gt; dist[u])\n            continue;\n\n        // Iterate over all outgoing edges from node u\n        for (auto&amp; [to, w] : adj[u]) {\n            // Check if a shorter path to 'to' is found\n            if (dist[to] &gt; dist[u] + w) {\n                // Update the shortest distance to 'to'\n                dist[to] = dist[u] + w;\n\n                // Update the number of ways to reach 'to' to be the same as 'u'\n                ways[to] = ways[u];\n\n                // Update the minimum number of flights to reach 'to'\n                min_flights[to] = min_flights[u] + 1;\n\n                // Update the maximum number of flights to reach 'to'\n                max_flights[to] = max_flights[u] + 1;\n\n                // Push the updated node into the priority queue\n                pq.emplace(dist[to], to);\n            }\n            // If another shortest path to 'to' is found with the same distance\n            else if (dist[to] == dist[u] + w) {\n                // Increment the number of ways to reach 'to' modulo MOD\n                ways[to] = (ways[to] + ways[u]) % MOD;\n\n                // Update the minimum number of flights if the new path uses fewer flights\n                min_flights[to] = min(min_flights[to], min_flights[u] + 1);\n\n                // Update the maximum number of flights if the new path uses more flights\n                max_flights[to] = max(max_flights[to], max_flights[u] + 1);\n            }\n        }\n    }\n\n    // After processing, check if node 'n' is reachable\n    if (dist[n] == INF) {\n        // If 'n' is unreachable, output -1 for all values\n        cout &lt;&lt; \"-1 \" &lt;&lt; \"0 \" &lt;&lt; \"-1 \" &lt;&lt; \"-1\\n\";\n    }\n    else {\n        // Output the shortest distance, number of ways, minimum flights, and maximum flights\n        cout &lt;&lt; dist[n] &lt;&lt; \" \" &lt;&lt; ways[n] &lt;&lt; \" \" &lt;&lt; min_flights[n] &lt;&lt; \" \" &lt;&lt; max_flights[n];\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/longest_flight_route.html","title":"Longest Flight Route","text":""},{"location":"CSES/graphs/longest_flight_route.html#dijkstra-algorithm-ove-log-v-tle","title":"Dijkstra Algorithm $O((V+E) \\log V)$ TLE","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;int, int&gt;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  int a, b;\n\n  vector&lt;vector&lt;pii&gt;&gt; adj(n+1);\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b;\n    adj[a].pb(b, 1);\n  }\n\n  priority_queue&lt;pii, vector&lt;pii&gt;&gt; pq; \n  pq.emplace(0, 1);\n  const int NEG_INF = -1e9;\n  vector&lt;int&gt; dist(n+1, NEG_INF);\n  vector&lt;int&gt; pred(n+1, -1);\n  dist[1] = 0;\n\n  while (!pq.empty()) {\n    auto [cur_dist, u] = pq.top();\n    pq.pop();\n\n    if (cur_dist &lt; dist[u])\n      continue;\n\n    for (auto&amp; [to, w] : adj[u]) {\n      if (dist[to] &lt; dist[u] + w) {\n        dist[to] = dist[u] + w;\n        pred[to] = u;\n        pq.emplace(dist[to], to);\n      }\n    }\n  }\n\n  if (dist[n] == NEG_INF) {\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n  }\n\n  cout &lt;&lt; dist[n] + 1 &lt;&lt; \"\\n\";\n\n  int start = n;\n  vector&lt;int&gt; ans;\n  ans.pb(start);\n  while (pred[start] != -1) {\n    start = pred[start];\n    ans.pb(start);\n  }\n  reverse(ans.begin(), ans.end());\n  int len = ans.size();\n  for (int i = 0; i &lt; len; i++) {\n    cout &lt;&lt; ans[i] &lt;&lt; (i == len-1 ? \"\\n\" : \" \");\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/longest_flight_route.html#topological-sort-v-e","title":"Topological Sort $(V + E)$","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;int, int&gt;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  int a, b;\n\n  vector&lt;vector&lt;int&gt;&gt; adj(n+1);\n  vector&lt;int&gt; in_degree(n+1);\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b;\n    adj[a].pb(b);\n    in_degree[b]++;\n  }\n\n  queue&lt;int&gt; q;\n  for (int i = 1; i &lt;= n; i++) {\n    if (in_degree[i] == 0)\n      q.push(i);\n  }\n\n  vector&lt;int&gt; topo_order;\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    topo_order.pb(u);\n    for (auto &amp; to : adj[u]) {\n      in_degree[to]--;\n      if (in_degree[to] == 0)\n        q.push(to);\n    }\n  }\n\n  // check if a graph has a cycle\n  if (topo_order.size() != n) {\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n  }\n\n  const int NEG_INF = -1e9;\n  vector&lt;int&gt; dist(n+1, NEG_INF);\n  vector&lt;int&gt; pred(n+1, -1);\n  dist[1] = 0;\n\n  for (auto&amp; v : topo_order) {\n    if (dist[v] == NEG_INF)\n      continue;\n\n    for (auto &amp;to : adj[v]) {\n      if (dist[to] &lt; dist[v] + 1) {\n        dist[to] = dist[v] + 1;\n        pred[to] = v;\n      }\n    }\n  }\n\n  if (dist[n] == NEG_INF) {\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n  }\n\n  vector&lt;int&gt; path;\n  int cur = n;\n  while (cur != -1) {\n    path.pb(cur);\n    cur = pred[cur];\n  }\n\n  reverse(path.begin(), path.end());\n\n  cout &lt;&lt; dist[n] + 1 &lt;&lt; \"\\n\";\n  int len = path.size();\n  for (int i = 0; i &lt; len; i++) {\n    cout &lt;&lt; path[i] &lt;&lt; (i == len-1 ? \"\\n\" : \" \");\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/longest_flight_route.html#bfs-find-shortest-route-in-unweighed-graph","title":"BFS find shortest route in unweighed graph","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    int a, b;\n    vector&lt;vector&lt;int&gt;&gt; adj(n + 1);\n    for(int i=0; i&lt;m; i++){\n        cin &gt;&gt; a &gt;&gt; b;\n        adj[a].emplace_back(b);\n    }\n\n    int source = 1, destination = n;\n    vector&lt;int&gt; dist(n + 1, -1);\n    vector&lt;int&gt; pred(n + 1, -1);\n    queue&lt;int&gt; q;\n\n    q.push(source);\n    dist[source] = 0;\n\n    while(!q.empty()){\n        int u = q.front(); q.pop();\n        for(auto &amp;v : adj[u]){\n            if(dist[v] == -1){\n                dist[v] = dist[u] + 1;\n                pred[v] = u;\n                q.push(v);\n            }\n        }\n    }\n\n    if(dist[destination] == -1){\n        cout &lt;&lt; \"IMPOSSIBLE\";\n        return 0;\n    }\n\n    // Reconstruct the path\n    vector&lt;int&gt; path;\n    int current = destination;\n    while(current != -1){\n        path.push_back(current);\n        current = pred[current];\n    }\n    reverse(path.begin(), path.end());\n\n    // Output\n    cout &lt;&lt; dist[destination] &lt;&lt; \"\\n\";\n    for(int i=0; i&lt;path.size(); i++){\n        cout &lt;&lt; path[i] &lt;&lt; (i == path.size()-1 ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/planets_cycles.html","title":"Planets Cycles","text":"<p>Solution: DFS</p> <p>Time Complexity: $O(n)$</p>"},{"location":"CSES/graphs/planets_cycles.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\nconst int MOD = 1e9+7;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; t(n+1);\n  for (int i = 1; i &lt;= n; i++)  {\n    cin &gt;&gt; t[i];\n  }\n\n  // 0=unvisited, 1=visiting, 2=done\n  vector&lt;int&gt; state(n+1, 0);\n  vector&lt;int&gt; ans(n+1, 0);\n  vector&lt;bool&gt; inCycle(n+1, false);\n\n  function&lt;void(int)&gt; dfs = [&amp;](int u) {\n    state[u] = 1;\n    int to = t[u];\n\n    if (state[to] == 0) {\n      dfs(to);\n    } else if (state[to] == 1) {\n      int cur = to;\n      int cycle_len = 0;\n\n      do {\n        cur = t[cur];\n        cycle_len++;\n      } while (cur != to);\n\n      cur = to;\n      do {\n        inCycle[cur] = true;\n        ans[cur] = cycle_len;\n        cur = t[cur];\n      } while (cur != to);\n    }\n\n    state[u] = 2;\n  };\n\n  for (int i = 1; i &lt;= n; i++) {\n    if (state[i] == 0) {\n      dfs(i);\n    }\n  }\n\n  function&lt;int(int)&gt; calcAns = [&amp;](int u) -&gt; int {\n    if (ans[u] != 0) return ans[u];\n\n    ans[u] = 1 + calcAns(t[u]);\n    return ans[u];\n  };\n\n  for (int i = 1; i &lt;= n; i++) {\n    if (!inCycle[i] &amp;&amp; ans[i] == 0)\n      calcAns(i);\n  }\n\n  for (int i = 1; i &lt;= n; i++) {\n    cout &lt;&lt; ans[i] &lt;&lt; (i == n ? \"\\n\" : \" \");\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/planets_cycles.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\n\n// Constants\nconst int MOD = 1e9+7; // Not used in this code but commonly used for modular arithmetic\nconst ll INF = 1e18;    // Representation of infinity\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin &gt;&gt; n; // Read number of nodes\n\n    vector&lt;int&gt; t(n + 1); // Transition array (1-based indexing)\n    for (int i = 1; i &lt;= n; i++)  {\n        cin &gt;&gt; t[i]; // Read the node each node points to\n    }\n\n    // State array to keep track of node states during DFS\n    // 0 = unvisited, 1 = visiting, 2 = done\n    vector&lt;int&gt; state(n + 1, 0);\n\n    // ans[i] will store the cycle length if node i is in a cycle\n    // or the number of steps to reach a cycle plus the cycle length if not in a cycle\n    vector&lt;int&gt; ans(n + 1, 0);\n\n    // inCycle[i] indicates whether node i is part of a cycle\n    vector&lt;bool&gt; inCycle(n + 1, false);\n\n    // Lambda function for DFS to detect cycles and assign cycle lengths\n    function&lt;void(int)&gt; dfs = [&amp;](int u) {\n        state[u] = 1; // Mark node as visiting\n        int to = t[u]; // Next node\n\n        if (state[to] == 0) {\n            // If the next node is unvisited, continue DFS\n            dfs(to);\n        } else if (state[to] == 1) {\n            // A cycle is detected\n            int cur = to;\n            int cycle_len = 0;\n\n            // Calculate the length of the cycle\n            do {\n                cur = t[cur];\n                cycle_len++;\n            } while (cur != to);\n\n            // Mark all nodes in the cycle and assign the cycle length\n            cur = to;\n            do {\n                inCycle[cur] = true; // Mark node as part of a cycle\n                ans[cur] = cycle_len; // Assign cycle length\n                cur = t[cur];\n            } while (cur != to);\n        }\n\n        state[u] = 2; // Mark node as done\n    };\n\n    // Perform DFS for each node to detect cycles\n    for (int i = 1; i &lt;= n; i++) {\n        if (state[i] == 0) {\n            dfs(i);\n        }\n    }\n\n    // Lambda function to calculate ans[i] for nodes not in any cycle\n    function&lt;int(int)&gt; calcAns = [&amp;](int u) -&gt; int {\n        if (ans[u] != 0) return ans[u]; // If already calculated, return the value\n\n        ans[u] = 1 + calcAns(t[u]); // Recursively calculate the steps to reach a cycle plus the cycle length\n        return ans[u];\n    };\n\n    // Calculate ans[i] for all nodes not part of any cycle\n    for (int i = 1; i &lt;= n; i++) {\n        if (!inCycle[i] &amp;&amp; ans[i] == 0)\n            calcAns(i);\n    }\n\n    // Output the ans[i] for each node\n    for (int i = 1; i &lt;= n; i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; (i == n ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/planets_queries_I.html","title":"Planets Queries I","text":"<p>Solution: Binary Lifting</p> <p>Time Complexity: $O(n \\times \\log k +  q \\times \\log k)$</p>"},{"location":"CSES/graphs/planets_queries_I.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\nconst int MOD = 1e9+7;\nconst ll INF = 1e18;\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, q;\n  cin &gt;&gt; n &gt;&gt; q;\n  vector&lt;int&gt; t(n+1);\n  for (int i = 1; i &lt;= n; i++)  {\n    cin &gt;&gt; t[i];\n  }\n\n  int LOG = 30;\n\n  // up[j][i] = 2^j th step from i\n  vector&lt;vector&lt;int&gt;&gt; up(LOG, vector&lt;int&gt;(n+1));\n  for (int i = 1; i &lt;= n; i++) {\n    up[0][i] = t[i];\n  }\n\n  for (int j = 1; j &lt; LOG; j++) {\n    for (int i = 1; i &lt;= n; i++) {\n      up[j][i] = up[j-1][up[j-1][i]];\n    }\n  }\n\n  while (q--) {\n    int x, k;\n    cin &gt;&gt; x &gt;&gt; k;\n    int cur = x;\n    for (int j = 0; j &lt; LOG; j++) {\n      if (k &amp; (1 &lt;&lt; j)) {\n        cur = up[j][cur];\n      }\n    }\n    cout &lt;&lt; cur &lt;&lt; \"\\n\";\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/planets_queries_I.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pb emplace_back\n#define pii pair&lt;ll, int&gt;\n\n// Constants\nconst int MOD = 1e9+7; // Not used in this particular code\nconst ll INF = 1e18;    // Representation of infinity\nconst int LOG = 30;     // Maximum power for binary lifting (covers k up to ~1e9)\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin &gt;&gt; n &gt;&gt; q; // Read number of nodes and number of queries\n\n    vector&lt;int&gt; t(n + 1); // Transition array (1-based indexing)\n    for (int i = 1; i &lt;= n; i++)  {\n        cin &gt;&gt; t[i]; // Read the node each node points to\n    }\n\n    // Initialize the binary lifting table\n    // up[j][i] = node reached after 2^j transitions from node i\n    // Initialize with size LOG x (n+1) for 1-based indexing\n    vector&lt;vector&lt;int&gt;&gt; up(LOG, vector&lt;int&gt;(n + 1));\n\n    // Base case: 2^0 = 1 transition\n    for (int i = 1; i &lt;= n; i++) {\n        up[0][i] = t[i];\n    }\n\n    // Build the sparse table\n    for (int j = 1; j &lt; LOG; j++) {\n        for (int i = 1; i &lt;= n; i++) {\n            // If up[j-1][i] is 0, it means no transition; set up[j][i] accordingly\n            // Assuming that node indices start from 1 and t[i] &gt;=1, else handle separately\n            up[j][i] = up[j-1][ up[j-1][i] ];\n        }\n    }\n\n    // Process each query\n    while (q--) {\n        int x;  // Starting node\n        ll k;   // Number of transitions\n        cin &gt;&gt; x &gt;&gt; k;\n\n        int cur = x; // Current node after transitions\n\n        // Iterate through each bit of k\n        for (int j = 0; j &lt; LOG; j++) {\n            // If the j-th bit of k is set, perform the corresponding jump\n            if (k &amp; (1LL &lt;&lt; j)) {\n                cur = up[j][cur];\n            }\n        }\n\n        // Output the result after k transitions\n        cout &lt;&lt; cur &lt;&lt; \"\\n\";\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/planets_queries_II.html","title":"Planets Queries II","text":"<p>Binary Lifting O(logk)</p>"},{"location":"CSES/graphs/shortest_routes_I.html","title":"Shortest Routes I","text":"<p>Solution: Dijkstra's algorithm</p> <p>Time Complexity: $O(E \\log V)$</p>"},{"location":"CSES/graphs/shortest_routes_I.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pii pair&lt;ll, int&gt;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; adj(n + 1);\n  for (int i = 0; i &lt; m; i++) {\n    int a, b;\n    ll c;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    adj[a].emplace_back(b, c);\n  }\n\n  vector&lt;ll&gt; dist(n+1, 1e18);\n  dist[1] = 0;\n  priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;\n  pq.emplace(0, 1);\n\n  while (!pq.empty()) {\n    auto [cur_dist, u] = pq.top();\n    pq.pop();\n\n    if (cur_dist &gt; dist[u])\n      continue;\n\n    for (auto&amp; [v, w] : adj[u]) {\n      if (dist[v] &gt; dist[u] + w) {\n        dist[v] = dist[u] + w;\n        pq.emplace(dist[v], v);\n      }\n    }\n  }\n\n  for (int i = 1; i &lt;= n; i++) {\n    cout &lt;&lt; dist[i] &lt;&lt; (i == n ? \"\\n\" : \" \");\n  }\n}\n</code></pre>"},{"location":"CSES/graphs/shortest_routes_I.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pii pair&lt;ll, int&gt;\n\nint main() {\n    // Optimize input and output operations\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m; // Read number of nodes and edges\n\n    // Adjacency list where adj[u] contains pairs of (v, w)\n    // representing an edge from u to v with weight w\n    vector&lt;vector&lt;pair&lt;int, ll&gt;&gt;&gt; adj(n + 1);\n\n    for (int i = 0; i &lt; m; i++) {\n        int a, b;\n        ll c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; // Read edge from a to b with weight c\n        adj[a].emplace_back(b, c); // Add edge to adjacency list\n    }\n\n    // Initialize distance array with \"infinity\"\n    const ll INF = 1e18;\n    vector&lt;ll&gt; dist(n + 1, INF);\n    dist[1] = 0; // Distance to source node is 0\n\n    // Priority queue to select the node with the smallest tentative distance\n    // pii is a pair of (distance, node)\n    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;\n    pq.emplace(0, 1); // Start with the source node\n\n    while (!pq.empty()) {\n        // Extract node with the smallest distance\n        auto [cur_dist, u] = pq.top();\n        pq.pop();\n\n        // If the current distance is greater than the recorded distance, skip\n        if (cur_dist &gt; dist[u])\n            continue;\n\n        // Iterate over all adjacent edges of node u\n        for (auto&amp; [v, w] : adj[u]) {\n            // If a shorter path to v is found through u\n            if (dist[v] &gt; dist[u] + w) {\n                dist[v] = dist[u] + w; // Update distance\n                pq.emplace(dist[v], v); // Add to priority queue\n            }\n        }\n    }\n\n    // Output the shortest distances from node 1 to all other nodes\n    for (int i = 1; i &lt;= n; i++) {\n        // If a node is unreachable, you might want to handle it differently\n        // For example, print -1 or \"INF\" instead of 1e18\n        cout &lt;&lt; dist[i] &lt;&lt; (i == n ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/shortest_routes_II.html","title":"Shortest Routes II","text":"<p>Solution: Floyd-Warshall algorithm</p> <p>Time Complexity: $O(n^3)$</p>"},{"location":"CSES/graphs/shortest_routes_II.html#code","title":"Code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pii pair&lt;ll, int&gt;\n#define INF 1e18\n\nll dist_mat[505][505];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, m, q;\n  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= n; j++) {\n      dist_mat[i][j] = (i == j ? 0 : INF);\n    }\n  }\n\n  int a, b;\n  ll c;\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    if (c &lt; dist_mat[a][b]) {\n      dist_mat[a][b] = c;\n      dist_mat[b][a] = c;\n    }\n  }\n\n  for (int k = 1; k &lt;= n; k++) {\n    for (int i = 1; i &lt;= n; i++) {\n      if (dist_mat[i][k] == INF)\n        continue;\n      for (int j = 1; j &lt;= n; j++) {\n        if (dist_mat[k][j] == INF)\n          continue;\n\n        if (dist_mat[i][j] &gt; dist_mat[i][k] + dist_mat[k][j])\n          dist_mat[i][j] = dist_mat[i][k] + dist_mat[k][j];\n      }\n    }\n  }\n\n  while (q--) {\n    cin &gt;&gt; a &gt;&gt; b;\n    if (dist_mat[a][b] &lt; INF) {\n      cout &lt;&lt; dist_mat[a][b] &lt;&lt; \"\\n\";\n    }\n    else {\n      cout &lt;&lt; \"-1\\n\";\n    }\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"CSES/graphs/shortest_routes_II.html#code-with-comment","title":"Code with Comment","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Type definitions for convenience\n#define ll long long\n#define pii pair&lt;ll, int&gt;\n#define INF 1e18\n\n// Define the maximum number of nodes based on the problem constraints\nconst int MAX_NODES = 505;\n\n// Initialize the distance matrix with INF\nll dist_mat[MAX_NODES][MAX_NODES];\n\nint main() {\n    // Optimize input and output operations for faster execution\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, m, q;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; // Read number of nodes, edges, and queries\n\n    // Initialize the distance matrix\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (i == j)\n                dist_mat[i][j] = 0; // Distance to self is zero\n            else\n                dist_mat[i][j] = INF; // Initialize other distances to infinity\n        }\n    }\n\n    // Read and process all edges\n    for (int i = 0; i &lt; m; i++) {\n        int a, b;\n        ll c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; // Read edge from node a to node b with weight c\n\n        // Since the graph is undirected, update both [a][b] and [b][a]\n        // Only update if the new edge has a smaller weight\n        if (c &lt; dist_mat[a][b]) {\n            dist_mat[a][b] = c;\n            dist_mat[b][a] = c;\n        }\n    }\n\n    // Floyd-Warshall Algorithm to compute all-pairs shortest paths\n    for (int k = 1; k &lt;= n; k++) { // Iterate through each possible intermediate node\n        for (int i = 1; i &lt;= n; i++) { // Iterate through each source node\n            // If the distance from i to k is already infinity, skip to avoid overflow\n            if (dist_mat[i][k] == INF)\n                continue;\n            for (int j = 1; j &lt;= n; j++) { // Iterate through each destination node\n                // If the distance from k to j is infinity, skip\n                if (dist_mat[k][j] == INF)\n                    continue;\n\n                // If a shorter path from i to j through k is found, update it\n                if (dist_mat[i][j] &gt; dist_mat[i][k] + dist_mat[k][j]) {\n                    dist_mat[i][j] = dist_mat[i][k] + dist_mat[k][j];\n                }\n            }\n        }\n    }\n\n    // Handle each query by outputting the shortest distance between two nodes\n    while (q--) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b; // Read query nodes a and b\n        if (dist_mat[a][b] &lt; INF) {\n            cout &lt;&lt; dist_mat[a][b] &lt;&lt; \"\\n\"; // Output the shortest distance\n        }\n        else {\n            cout &lt;&lt; \"-1\\n\"; // Output -1 if no path exists\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"CSES/mathematics/Counting_Coprime_Pairs.html","title":"Counting Coprime Pairs","text":"<p>notice long long</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; v(n);\n  int mx = 0;\n  for (auto&amp; num : v) {\n    cin &gt;&gt; num;\n    mx = max(mx, num);\n  }\n\n  vector&lt;int&gt; freq(mx + 1, 0);\n  for (auto num : v) {\n    freq[num]++;\n  }\n\n  vector&lt;int&gt; mu(mx + 1, 1);\n  vector&lt;bool&gt; isPrime(mx + 1, true);\n  for (int i = 2; i &lt;= mx; i++) {\n    if (isPrime[i]) {\n      for (int j = i; j &lt;= mx; j+=i) {\n        isPrime[j] = false;\n        mu[j] *= -1;\n      }\n\n      ll sq = (ll)i * i;\n      for (ll j = sq; j &lt;= mx; j+=sq) {\n        mu[j] = 0;\n      }\n    }\n  }\n\n  vector&lt;int&gt; multiple(mx + 1, 0);\n  for (int i = 1; i &lt;= mx; i++) {\n    for (int j = i; j &lt;= mx; j+=i) {\n      multiple[i] += freq[j];\n    }\n  }\n\n  ll ans = 0;\n  for (int i = 1; i &lt;= mx; i++) {\n    if (mu[i] == 0)\n      continue;\n\n    ll cnt = (ll)multiple[i];\n    if (cnt &lt; 2)\n      continue;\n\n    ll pairs = (cnt * (cnt - 1)) / 2;\n    ans += (mu[i] * pairs);\n  }\n\n\n  cout &lt;&lt; ans;\n\n  return 0;\n}\n</code></pre>"},{"location":"Codeforces/dp/explorer_space.html","title":"D. Explorer Space","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define INF 1e9\n#define fore(i, a, b) for (int i = (a); i &lt; (b); i++)\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m, k;\n  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n\n  vector&lt;vector&lt;int&gt;&gt; h(n, vector&lt;int&gt;(m-1, 0));\n  fore(i, 0, n) {\n    fore(j, 0, m-1) {\n      cin &gt;&gt; h[i][j];\n    }\n  }\n\n  vector&lt;vector&lt;int&gt;&gt; v(n-1, vector&lt;int&gt;(m, 0));\n  fore(i, 0, n-1) {\n    fore(j, 0, m) {\n      cin &gt;&gt; v[i][j];\n    }\n  }\n\n  if (k % 2 != 0) {\n    fore(i, 0, n) {\n      fore(j, 0, m) {\n        cout &lt;&lt; \"-1\" &lt;&lt; (j == m-1 ? \"\\n\" : \" \");\n      }\n    }\n\n    return 0;\n  }\n\n  vector&lt;vector&lt;int&gt;&gt; previous(n, vector&lt;int&gt;(m, 0));\n  vector&lt;vector&lt;int&gt;&gt; current(n, vector&lt;int&gt;(m, INF));\n  k /= 2;\n  fore(t, 0, k) {\n    fore(i, 0, n) {\n      fore(j, 0, m) {\n        int min_cost = INF;\n\n        // UP\n        if (i &gt; 0) { min_cost = min(min_cost, 2*v[i-1][j] + previous[i-1][j]); }\n\n        // DOWN\n        if (i &lt; n-1) {\n          min_cost = min(min_cost, 2*v[i][j] + previous[i+1][j]);\n        }\n\n        // LEFT\n        if (j &gt; 0) {\n          min_cost = min(min_cost, 2*h[i][j-1] + previous[i][j-1]);\n        }\n\n        // RIGHT\n        if (j &lt; m-1) {\n          min_cost = min(min_cost, 2*h[i][j] + previous[i][j+1]);\n        }\n\n        current[i][j] = min_cost;\n      }\n    }\n    current.swap(previous);\n  }\n\n  fore(i, 0, n) {\n    fore(j, 0, m) {\n      if (previous[i][j] &gt;= INF) {\n        cout &lt;&lt; \"-1\";\n      }\n      else {\n        cout &lt;&lt; previous[i][j];\n      }\n      cout &lt;&lt; (j == m-1 ? \"\\n\" : \" \");\n    }\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"Codeforces/graphs/cyclic_components.html","title":"E. Cyclic Components","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define pb push_back\n\nconst int N = 200005;\nint ans;\nvector&lt;int&gt; g[N];\nvector&lt;int&gt; comp;\nint deg[N];\nbool used[N];\n\n// dfs recursive\nvoid dfs(int v) {\n  used[v] = true;\n  comp.pb(v);\n\n  for (auto to : g[v]) {\n    if (!used[to]) {\n      dfs(to);\n    }\n  }\n}\n\n// dfs iterative\nvoid dfsi(int start) {\n  stack&lt;int&gt; s;\n  s.push(start);\n  used[start] = true;\n\n  while (!s.empty()) {\n    int v = s.top();\n    s.pop();\n    comp.pb(v);\n\n    for (auto to : g[v]) {\n      if (!used[to]) {\n        used[to] = true;\n        s.push(to);\n      }\n    }\n  }\n\n}\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, m, x, y;\n  cin &gt;&gt; n &gt;&gt; m;\n  for (int i = 0; i &lt; m; i++) {\n    cin &gt;&gt; x &gt;&gt; y;\n    x--;\n    y--;\n    g[x].pb(y);\n    g[y].pb(x);\n    deg[x]++;\n    deg[y]++;\n  }\n\n  for (int i = 0; i &lt; n; i++) {\n    if (!used[i]) {\n      comp.clear();\n      dfs(i);\n      bool ok = all_of(comp.begin(), comp.end(), [&amp;](int v){return deg[v] == 2;});\n      if (ok) ans++;\n    }\n  }\n\n  cout &lt;&lt; ans;\n\n  return 0;\n}\n</code></pre>"},{"location":"Codeforces/graphs/journey.html","title":"C. Journey","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define pb push_back\n\nconst int N = 100005;\n\nvector&lt;int&gt; g[N];\ndouble ans;\nbool used[N];\nvector&lt;int&gt; pathLen;\n\nvoid dfs(int start, double prob, int depth) {\n  used[start] = true;\n  bool isLeaf = true;\n\n  int below = 0;\n  for (auto to : g[start]) {\n    if (!used[to]) {\n      below++;\n    }\n  }\n\n  for (auto to : g[start]) {\n    if (!used[to]) {\n      isLeaf = false;\n      dfs(to, prob/below, depth+1);\n    }\n  }\n\n  if (isLeaf)\n    ans += prob * depth;\n}\n\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, x, y;\n  cin &gt;&gt; n;\n  for (int i = 0 ; i &lt; n-1; i++) {\n    cin &gt;&gt; x &gt;&gt; y;\n    x--;\n    y--;\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n\n\n  dfs(0, 1.0, 0);\n\n  cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; ans;\n\n  return 0;\n}\n</code></pre>"},{"location":"Codeforces/graphs/kefa_and_park.html","title":"C. Kefa and Park","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define pb push_back\nvector&lt;int&gt; v[100005];\nint m, n, x, y;\nint cat[100005];\nint ans;\n\n// v = head of any row of adjacency list\n// pr = parent\nvoid dfs(int cur, int pr, int nCats) {\n  if (nCats &gt; n)\n    return;\n\n  int isLeaf = 1;\n\n  for (int neighbor : v[cur]) {\n    if (neighbor != pr) {\n      isLeaf = 0;\n      dfs(neighbor, cur, (cat[neighbor] ? nCats + 1 : 0));\n    }\n  }\n\n  if (isLeaf)\n    ans += isLeaf;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin &gt;&gt; m &gt;&gt; n;\n  for (int i = 0; i &lt; m; i++)\n    cin &gt;&gt; cat[i];\n  for (int i = 1; i &lt; m; i++) {\n    cin &gt;&gt; x &gt;&gt; y;\n    x--;\n    y--;\n    v[x].pb(y);\n    v[y].pb(x);\n  }\n\n  dfs(0, -1, cat[0]);\n\n  cout &lt;&lt; ans;\n\n  // for (int i = 0; i &lt; m; i++) {\n  //   for (int j = 0; j &lt; m; j++) {\n  //     cout &lt;&lt; v[i][j] &lt;&lt; \" \";\n  //   }\n  //   cout &lt;&lt; \"\\n\";\n  // }\n\n\n  return 0;\n}\n</code></pre>"},{"location":"Codeforces/graphs/minimal_height_tree.html","title":"D. Minimal Height Tree","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define pb push_back\n\nconst int N = 100005;\n\n\n// in minumim height tree, ascending vertices are at same level, if not, at next level\nvoid solve() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;int&gt; a(n);\n  for (int i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n  }\n\n\n  vector&lt;int&gt; h(n, 0);\n  h[0] = 0;\n  int lst = 0;\n  for (int i = 1; i &lt; n; i++) {\n    // iterate last depth's vertices\n    if (i - 1 &gt; 0 &amp;&amp; a[i-1] &gt; a[i])\n      lst++;\n    h[i] = h[lst] + 1;\n  }\n\n  for (int i = 0; i &lt; n; i++)\n    cout &lt;&lt; h[i] &lt;&lt; \" \";\n  cout &lt;&lt; endl;\n  cout &lt;&lt; h[n-1] &lt;&lt; '\\n';\n\n}\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin &gt;&gt; t;\n  while (t--) {\n    solve();\n  }\n\n  return 0;\n}\n</code></pre>"}]}